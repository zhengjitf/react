## batchedUpdates
由 `React-DOM` 导出，在 `packages/react-reconciler/src/ReactFiberWorkLoop.js` 定义

```js
export function batchedUpdates<A, R>(fn: A => R, a: A): R {
  const prevExecutionContext = executionContext;
  executionContext |= BatchedContext;
  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;
    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      flushSyncCallbackQueue();
    }
  }
}
```
第一个参数是要执行的函数，之后的参数是要传入函数的参数，在函数执行前 `executionContext |= BatchedContext` 在当前执行上下文添加 `BatchedContext` ，执行过程中比如调用 `scheduleWork (scheduleUpdateOnFiber)` 会判断 `executionContext`，如果带上 `BatchedContext` 会跳过不执行 `performSyncWorkOnRoot`，执行结束后，还原 `executionContext` 判断如果没有任何值，则调用 `flushSyncCallbackQueue`

```js
const [state, setState] = useState(0)

batchedUpdates(() => {
  // 这一步调用的是 dispatchAction 生成一个 update 挂载到 fiber.updateQueue.pending 上
  /**
   *  
   * update = {
      expirationTime: ...,
      suspenseConfig: ...,
      action: 10,
      eagerReducer: defaultReducer,
      eagerState: 10,
      next: null
    }
   * 
   * */
  setState(10)

  // 也是调用 dispatchAction ， 但和上一步不同的是这里不会计算 eagerState，然后调用 scheduleWork 因为是 batchedUpdates，所以会跳过 commit 的操作，最后执行 batchedUpdates 中的 flushSyncCallbackQueue，然后调用 renderWithHooks => 调用函数组件 => usestate => updateReducer (在 while 循环中遍历整个 update 队列，计算最终的 newState 赋值给 hook.memoizedState 和 queue.lastRenderedState)
  // 这里的 n 为 10
  setState(n => n + 1)
})
```


