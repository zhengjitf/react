
## batchedUpdates
由 `React-DOM` 导出，在 `packages/react-reconciler/src/ReactFiberWorkLoop.js` 定义

```js
export function batchedUpdates<A, R>(fn: A => R, a: A): R {
  const prevExecutionContext = executionContext;
  executionContext |= BatchedContext;
  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;
    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      flushSyncCallbackQueue();
    }
  }
}
```

### scheduleWork (scheduleUpdateOnFiber)
> packages/react-reconciler/src/ReactFiberWorkLoop.js

```js
function scheduleUpdateOnFiber(
  fiber: Fiber,
  expirationTime: ExpirationTime,
) {
  // ....
  
  if (expirationTime === Sync) {
    if (
      (executionContext & LegacyUnbatchedContext) !== NoContext &&
      (executionContext & (RenderContext | CommitContext)) === NoContext
    ) { // 如果是 unbatchedUpdates 中执行 setState 会同步执行更新
      schedulePendingInteractions(root, expirationTime);

      performSyncWorkOnRoot(root); // 这里会同步提交更新（内部会调用 commitRoot）
    } else {
      // 如果是 react 事件回调中或 batchedUpdates 中调用 setState，会将 performSyncWorkOnRoot 作为调度回调推入 `syncQueue`，在 batchedUpdates 最后会调用 `flushSyncCallbackQueue`，执行 syncQueue 中的回调
      ensureRootIsScheduled(root);
      schedulePendingInteractions(root, expirationTime);
      if (executionContext === NoContext) { // 比如 setTimeout 或 原生事件回调中调用 setState，会同步执行更新
        flushSyncCallbackQueue();
      }
    }
  } else {
    // ...
  }

  // ....
}
```


### 类组件中

```js

```

### 函数组件中

```js
const [state, setState] = useState(0)

batchedUpdates(() => {
  // 这一步调用的是 dispatchAction 生成一个 update 挂载到 fiber.updateQueue.pending 上
  /**
   *  
   * update = {
      expirationTime: ...,
      suspenseConfig: ...,
      action: 10,
      eagerReducer: defaultReducer,
      eagerState: 10,
      next: null
    }
   * 
   * */
  setState(10)

  // 也是调用 dispatchAction ， 但和上一步不同的是这里不会计算 eagerState，然后调用 scheduleWork 因为是 batchedUpdates，所以会跳过 commit 的操作，最后执行 batchedUpdates 中的 flushSyncCallbackQueue，然后调用 renderWithHooks => 调用函数组件 => usestate => updateReducer (在 while 循环中遍历整个 update 队列，计算最终的 newState 赋值给 hook.memoizedState 和 queue.lastRenderedState)
  // 这里的 n 为 10
  setState(n => n + 1)
})
```


